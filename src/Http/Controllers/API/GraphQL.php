<?php

namespace ChiefTools\SDK\Http\Controllers\API;

use GraphQL\Type\Schema;
use Illuminate\Http\Request;
use Illuminate\Http\Response;
use GraphQL\Type\Introspection;
use GraphQL\Utils\SchemaPrinter;
use Laragraph\Utils\RequestParser;
use GraphQL\Type\Definition\UnionType;
use GraphQL\Type\Definition\InterfaceType;
use Nuwave\Lighthouse\Events\ManipulateAST;
use Nuwave\Lighthouse\Schema\SchemaBuilder;
use Nuwave\Lighthouse\GraphQL as Lighthouse;
use Nuwave\Lighthouse\Http\GraphQLController;
use Nuwave\Lighthouse\Federation\ASTManipulator;
use Nuwave\Lighthouse\Schema\Source\SchemaStitcher;
use ChiefTools\SDK\GraphQL\Directives\LocalDirective;
use Nuwave\Lighthouse\Support\Contracts\CreatesContext;
use Nuwave\Lighthouse\Support\Contracts\CreatesResponse;
use Illuminate\Contracts\Events\Dispatcher as EventsDispatcher;
use Symfony\Component\HttpFoundation\Response as SymfonyResponse;

class GraphQL extends GraphQLController
{
    public function __invoke(
        Request $request,
        Lighthouse $graphQL,
        EventsDispatcher $eventsDispatcher,
        RequestParser $requestParser,
        CreatesResponse $createsResponse,
        CreatesContext $createsContext,
    ): SymfonyResponse {
        sync_user_timezone();

        // If we are in a local environment we print the schema and possible types configuration
        // on every request it's a bit wasteful but the impact is not that big and it saves
        // setting up git hooks and all that horrible jazz. For apollo and GitHub diffs.
        if (app()->environment('local')) {
            $schema = app(SchemaBuilder::class)->schema();

            $fragmentTypes = /** @lang JavaScript */
                <<<JSEXPORT
                /** Generated by \ChiefTools\SDK\Http\Controllers\API\GraphQL **/
                const fragmentTypes = JSON.parse('{$this->extractFragmentTypesJSON($schema)}');
                export default fragmentTypes;
                JSEXPORT;

            // Prevent constantly updating the fragmentTypes.js causing `yarn run watch` to work on every API request
            if (!file_exists($fragmentTypesPath = resource_path('js/api/possibleTypes.js')) || file_get_contents($fragmentTypesPath) !== $fragmentTypes) {
                file_put_contents($fragmentTypesPath, $fragmentTypes);
            }

            $exportedSchema = SchemaPrinter::doPrint($schema);

            // Prevent constantly updating the schema.public.graphql causing reindex work on every API request
            if (!file_exists($exportedSchemaFilePath = base_path('resources/graphql/schema.public.graphql')) || file_get_contents($exportedSchemaFilePath) !== $exportedSchema) {
                file_put_contents($exportedSchemaFilePath, $exportedSchema);
            }

            $introspectionSchema = json_encode(Introspection::fromSchema($schema));

            // Prevent constantly updating the schema.json causing reindex work on every API request
            if (!file_exists($introspectionSchemaFilePath = base_path('resources/graphql/schema.public.json')) || file_get_contents($introspectionSchemaFilePath) !== $introspectionSchema) {
                file_put_contents($introspectionSchemaFilePath, $introspectionSchema);
            }
        }

        return parent::__invoke($request, $graphQL, $eventsDispatcher, $requestParser, $createsResponse, $createsContext);
    }

    public function schema(SchemaBuilder $schemaBuilder): Response
    {
        $schema = SchemaPrinter::doPrint($schemaBuilder->schema());

        $appId = config('chief.id', 'app');

        return response()->make($schema, 200, [
            'Content-Type'        => 'text/plain',
            'Content-Disposition' => "inline; filename=\"{$appId}-schema.graphql\"",
        ]);
    }

    public function federated(
        Request $request,
        Lighthouse $graphQL,
        EventsDispatcher $eventsDispatcher,
        RequestParser $requestParser,
        CreatesResponse $createsResponse,
        CreatesContext $createsContext,
    ): SymfonyResponse {
        abort_unless(config('chief.graphql.federation.enabled'), 404);

        $federationToken = $request->header('chief-federation-token', $request->input('federation_token'));

        abort_if(empty($federationToken), 400, 'Missing required federation token.');
        abort_unless(config('chief.graphql.federation.secret') === $federationToken, 403, 'Invalid federation token.');

        /** @var \Nuwave\Lighthouse\Schema\SchemaBuilder $schemaBuilder */
        $schemaBuilder = __access_class_property($graphQL, 'schemaBuilder');

        /** @var \Nuwave\Lighthouse\Schema\AST\ASTBuilder $astBuilder */
        $astBuilder = __access_class_property($schemaBuilder, 'astBuilder');

        $schemaPath = str_replace('schema.graphql', 'schema-federated.graphql', config('lighthouse.schema_path'));

        __set_class_property($astBuilder, 'schemaSourceProvider', new SchemaStitcher($schemaPath));

        /** @var \Nuwave\Lighthouse\Schema\AST\ASTCache $astCache */
        $astCache = __access_class_property($astBuilder, 'astCache');

        $schemaCachePath = str_replace('schema.php', 'schema-federated.php', config('lighthouse.schema_cache.path'));

        __set_class_property($astCache, 'path', $schemaCachePath);

        LocalDirective::markRequestAsFederated();

        $eventsDispatcher->listen(ManipulateAST::class, ASTManipulator::class);

        return $this($request, $graphQL, $eventsDispatcher, $requestParser, $createsResponse, $createsContext);
    }

    public function discovery(): array
    {
        $name  = config('app.name');
        $appId = config('chief.id');

        return [
            'title'          => $name,
            'description'    => "The {$name} GraphQL API.",
            'favicon_url'    => static_asset("icons/{$appId}_favicon.svg"),
            'logo_light_url' => static_asset("icons/{$appId}.svg"),
            'logo_dark_url'  => static_asset("icons/{$appId}_white.svg"),
        ];
    }

    private function extractFragmentTypesJSON(Schema $schema): string
    {
        $possibleTypes = [];

        foreach ($schema->getTypeMap() as $name => $type) {
            if ($type instanceof UnionType || $type instanceof InterfaceType) {
                $possibleTypeNames = [];

                foreach ($schema->getPossibleTypes($type) as $possibleType) {
                    $possibleTypeNames[$possibleType->name] = [
                        'name' => $possibleType->name,
                    ];
                }

                if (!empty($possibleTypeNames)) {
                    $possibleTypes[$name] = [
                        'kind'          => strtoupper(str_replace_last('Type', '', class_basename($type))),
                        'name'          => $name,
                        'possibleTypes' => array_values($possibleTypeNames),
                    ];
                }
            }
        }

        return js_json_encode([
            '__schema' => [
                'types' => array_values($possibleTypes),
            ],
        ]);
    }
}
