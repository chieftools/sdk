<?php

namespace IronGate\Chief\Http\Controllers\API;

use GraphQL\Type\Schema;
use Illuminate\Http\Request;
use Illuminate\Http\Response;
use GraphQL\Type\Introspection;
use GraphQL\Utils\SchemaPrinter;
use Laragraph\Utils\RequestParser;
use GraphQL\Type\Definition\UnionType;
use GraphQL\Type\Definition\InterfaceType;
use Nuwave\Lighthouse\Schema\SchemaBuilder;
use Nuwave\Lighthouse\GraphQL as Lighthouse;
use Nuwave\Lighthouse\Support\Contracts\CreatesContext;
use Nuwave\Lighthouse\Support\Contracts\CreatesResponse;
use Illuminate\Contracts\Events\Dispatcher as EventsDispatcher;
use Nuwave\Lighthouse\Support\Http\Controllers\GraphQLController;
use Symfony\Component\HttpFoundation\Response as SymfonyResponse;

class GraphQL extends GraphQLController
{
    public function __invoke(
        Request $request,
        Lighthouse $graphQL,
        EventsDispatcher $eventsDispatcher,
        RequestParser $requestParser,
        CreatesResponse $createsResponse,
        CreatesContext $createsContext,
    ): SymfonyResponse {
        sync_user_timezone();

        // If we are in a local environment we print the schema and possible types configuration
        // on every request it's a bit wasteful but the impact is not that big and it saves
        // setting up git hooks and all that horrible jazz. For apollo and GitHub diffs.
        if (app()->environment('local')) {
            $schema = app(SchemaBuilder::class)->schema();

            $fragmentTypes = /** @lang JavaScript */
                <<<JSEXPORT
                /** Generated by \IronGate\Chief\Http\Controllers\API\GraphQL **/
                const fragmentTypes = JSON.parse('{$this->extractFragmentTypesJSON($schema)}');
                export default fragmentTypes;
                JSEXPORT;

            // Prevent constantly updating the fragmentTypes.js causing `yarn run watch` to work on every API request
            if (!file_exists($fragmentTypesPath = resource_path('js/api/possibleTypes.js')) || file_get_contents($fragmentTypesPath) !== $fragmentTypes) {
                file_put_contents($fragmentTypesPath, $fragmentTypes);
            }

            $exportedSchema = SchemaPrinter::doPrint($schema);

            // Prevent constantly updating the schema.public.graphql causing reindex work on every API request
            if (!file_exists($exportedSchemaFilePath = base_path('resources/graphql/schema.public.graphql')) || file_get_contents($exportedSchemaFilePath) !== $exportedSchema) {
                file_put_contents($exportedSchemaFilePath, $exportedSchema);
            }

            $introspectionSchema = json_encode(Introspection::fromSchema($schema));

            // Prevent constantly updating the schema.json causing reindex work on every API request
            if (!file_exists($introspectionSchemaFilePath = base_path('resources/graphql/schema.public.json')) || file_get_contents($introspectionSchemaFilePath) !== $introspectionSchema) {
                file_put_contents($introspectionSchemaFilePath, $introspectionSchema);
            }
        }

        return parent::__invoke($request, $graphQL, $eventsDispatcher, $requestParser, $createsResponse, $createsContext);
    }

    public function schema(SchemaBuilder $schemaBuilder): Response
    {
        $schema = SchemaPrinter::doPrint($schemaBuilder->schema());

        $appId = config('chief.id', 'app');

        return response()->make($schema, 200, [
            'Content-Type'        => 'text/plain',
            'Content-Disposition' => "inline; filename=\"{$appId}-schema.graphql\"",
        ]);
    }

    private function extractFragmentTypesJSON(SChema $schema): string
    {
        $possibleTypes = [];

        foreach ($schema->getTypeMap() as $name => $type) {
            if ($type instanceof UnionType || $type instanceof InterfaceType) {
                $possibleTypeNames = [];

                foreach ($schema->getPossibleTypes($type) as $possibleType) {
                    $possibleTypeNames[$possibleType->name] = [
                        'name' => $possibleType->name,
                    ];
                }

                if (!empty($possibleTypeNames)) {
                    $possibleTypes[$name] = [
                        'kind'          => strtoupper(str_replace_last('Type', '', class_basename($type))),
                        'name'          => $name,
                        'possibleTypes' => array_values($possibleTypeNames),
                    ];
                }
            }
        }

        return js_json_encode([
            '__schema' => [
                'types' => array_values($possibleTypes),
            ],
        ]);
    }
}
